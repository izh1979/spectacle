#!/usr/bin/python -tt
# vim: ai ts=4 sts=4 et sw=4

#    Copyright (c) 2009 Intel Corporation
#
#    This program is free software; you can redistribute it and/or modify it
#    under the terms of the GNU General Public License as published by the Free
#    Software Foundation; version 2 of the License
#
#    This program is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#    for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc., 59
#    Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Overview of spec2spectacle
"""

import os
import sys
import re
import optparse

# spectacle modules
from spectacle.convertor import *
from spectacle.dumper import *

class SpecError(Exception):
    def __ini__(self, cur_state, cur_pkg, cur_line):
        self.cur_state = cur_state
        self.cur_pkg = cur_pkg
        self.cur_line = cur_line

    def __repr__(self):
        return self.cur_state + self.cur_pkg + self.cur_line

class SpecFormatError(SpecError):
    pass

class SpecUnknowLineError(SpecError):
    pass

class SpecUnknowHeaderError(SpecError):
    pass

HEADERS = ( 'package',
            'description',
            'prep',
            'build',
            'install',
            'clean',
            'post',
            'postun',
            'files',
            'changelog' )
SINGLES = ( 'Summary',
            'Name',
            'Version',
            'Release',
            'Epoch',
            'URL',
            'Url',
            'Group',
            'BuildArch',
            'License' )
SKIPS   = ( 'BuildRoot',)

# must have keys for 'main' package
MUSTHAVE = {'Release': '1',
           }

# state definition of parser
(
    ST_DEFINE,
    ST_MAIN,
    ST_INLINE,
    ST_SUBPKG,
)   = range(4)

class SpecConvertor(Convertor):
    """ Convertor for SpecBuild ini files """

    def __init__(self):
        sb_cv_table = {
                'BuildRequires': 'PkgBR',
                'PkgConfig': 'PkgConfigBR',
                'pre': 'install-pre',
                'description': 'Description',
                'Requires(post)': 'RequiresPost',
                'Requires(postun)': 'RequiresPostUn',
                'Requires(pre)': 'RequiresPre',
                'Requires(preun)': 'RequiresPreUn',
                'Url': 'URL',
                }
        Convertor.__init__(self, sb_cv_table)

class SpecParser(object):
    """ Parser of SPEC file of rpm package """

    def __init__(self, replace_macros, builder_parsing):
        # runtime variables
        self.items = {}
        self.table = {}
        self.cur_pkg = 'main'

        self.builder_parsing = builder_parsing
        self._Builder = None
        self._Configure = None

        self.replace_macros = replace_macros
        self.macros = []

    def __switch_subpkg(self, subpkg):
        if 'SubPackages' not in self.items:
            self.items['SubPackages'] = {}
        if subpkg not in self.items['SubPackages']:
            self.items['SubPackages'][subpkg] = {}

        return self.items['SubPackages'][subpkg]

    def _do_package(self, items, pkg, v):
        # skip
        pass

    def _do_prep(self, items, pkg, v):
        # skip
        pass

    def _do_build(self, items, pkg, v):
        """ to handle build script:
            trying to find out the most of the generic cases
        """

        def __save_raw_in_post(items, lines):
            # make sure no 'make' generated auto
            items['Builder'] = 'no-builder'
            # put all script to 'post install'
            items['extra']['PostMakeExtras'] = \
                    ['# all build scripts in origin specfile as the following:'] + lines

        ### Sub START
        lines = v.split('\n')
        if lines[0].startswith('-'):
            lines.pop(0)

        if not self.builder_parsing:
            __save_raw_in_post(items, lines)
            return

        # parts of build script
        (PRE, POST_CFG, POST_BUILD) = range(3)
        parts = { 'pre': [], 'post': [] }
        cur_part = PRE

        cont_line = False
        for line in lines:
            if cont_line:
                whole_line = whole_line + ' ' + line.strip()
            else:
                if not line.strip():
                    # empty line, skip
                    continue

                whole_line = line.strip()

            if line[-1:] == '\\':
                cont_line = True
                whole_line = whole_line[:-1].strip()
                continue
            else:
                cont_line = False

            found_cfgr = False
            found_bldr = False

            # find configure in current line
            for cfgr in ('configure', 'reconfigure', 'autogen'):
                pieces = whole_line.split()
                if cfgr in pieces or '%'+cfgr in pieces:
                    found_cfgr = True
                    self._Configure = cfgr
                    cfgr_line = whole_line
                    break

            # find builder in current line
            if re.match('^(%__)?make', whole_line):
                found_bldr = True
                self._Builder = 'make'
            elif re.search('python\W+setup.py\W+build', whole_line):
                found_bldr = True
                self._Builder = 'python'

            if cur_part == PRE:
                if found_cfgr:
                    cur_part = POST_CFG
                elif found_bldr:
                    cur_part = POST_BUILD
                else:
                    parts['pre'].append(whole_line)

            elif cur_part == POST_CFG:
                if found_cfgr:
                    # more 'configr', wrong
                    cur_part = PRE
                    break
                elif found_bldr:
                    cur_part = POST_BUILD
                else:
                    # another line(s) between configr and buildr, wrong
                    # or no supported buildr found, wrong
                    cur_part = PRE
                    break

            elif cur_part == POST_BUILD:
                parts['post'].append(whole_line)

        if cur_part == PRE:
            # means match failed
            __save_raw_in_post(items, lines)
        else:
            if self._Configure:
                items['Configure'] = self._Configure
                # parse the configure options
                for opt in cfgr_line.split()[1:]:
                    if 'ConfigOptions' not in items:
                        items['ConfigOptions'] = [opt]
                    else:
                        items['ConfigOptions'].append(opt)

            if self._Builder:
                items['Builder'] = self._Builder

            items['extra']['PreMakeExtras'] = \
                    ['# The followings are the origin script in this spec file'] + \
                    map(lambda s: '# >> ' + s, lines)

            if parts['pre']:
                items['extra']['PreMakeExtras'].extend(['', '# splitted pre-build part by auto-parsing'] + parts['pre'])
            if parts['post']:
                items['extra']['PostMakeExtras'] = ['# splitted post-build part by auto-parsing'] + parts['post']

    def _do_install(self, items, pkg, v):
        """ to handle install script:
            trying to find out the most of the generic cases
        """

        lines = v.split('\n')
        if lines[0].startswith('-'):
            lines.pop(0)

        # try to search %find_lang
        filter_lines = []
        for line in lines:
            if line.startswith('%find_lang'):
                m = re.compile('^%find_lang\s+(.*)\s*').match(line)
                if m:
                    items['LocaleName'] = m.group(1)
                    continue

            filter_lines.append(line)
        lines = filter_lines

        parts = { 'pre': [], 'post': [] }

        if self._Builder == 'make':
            re_installer = re.compile('make[_ \t]*install')
        elif self._Builder == 'python':
            re_installer = re.compile('python\W+setup.py\W+install')

        re_cleanup = re.compile('rm\W+-rf\W+(\$RPM_BUILD_ROOT|\%\{buildroot\})')

        if self._Builder:
            # have found 'Builder' in build scripts

            found_insaller = False
            for line in lines:
                if not found_insaller:
                    if re_installer.search(line):
                        found_insaller = True
                    elif re_cleanup.search(line):
                        # skip cleanup line
                        pass
                    else:
                        parts['pre'].append(line)
                else:
                    parts['post'].append(line)

            if found_insaller:
                items['extra']['PreMakeInstallExtras'] = \
                        ['# The followings are the origin script in this spec file'] + \
                        map(lambda s: '# >> ' + s, lines)

                if parts['pre']:
                    items['extra']['PreMakeInstallExtras'].extend(['', '# splitted pre-install part by auto-parsing'] + parts['pre'])
                if parts['post']:
                    items['extra']['PostMakeInstallExtras'] = ['# splitted post-install part by auto-parsing'] + parts['post']

                return

        # false safe case
        items['extra']['PostMakeInstallExtras'] = ['# all install scripts in origin specfile as the following:'] + lines

    def _do_clean(self, items, pkg, v):
        # skip
        pass

    def _do_post(self, items, pkg, v):
        # skip
        pass

    def _do_postun(self, items, pkg, v):
        # skip
        pass

    def _do_changelog(self, items, pkg, v):
        # TODO
        print 'TODO: move changelog to new file'

    def _do_files(self, items, pkg, v):
        files = map(str.strip, v.strip().split('\n'))

        # skip option line
        if files[0].startswith('-'):
            files.pop(0)

        try:
            files.remove('%defattr(-,root,root,-)')
        except ValueError:
            pass
        items['extra']['Files'] = files

    def _do_description(self, items, pkg, v):
        items['Description'] = v.strip()

    def read(self, filename):
        """ read in all recognized directives and headers """

        comment = re.compile('^#.*')
        directive = re.compile('^([\w()]+):[ \t]*(.*)')
        define_re = re.compile('^%define\s+(\w+)\s+(.*)')
        header_re = re.compile('^%(prep|build|install|clean|postun|post|files|changelog|package|description)\s*(.*)')

        state = ST_DEFINE
        items = self.items
        for line in file(filename):

            if state == ST_DEFINE:
                m = define_re.match(line.strip())
                if m:
                    if self.replace_macros:
                        self.table[m.group(1)] = m.group(2)
                    else:
                        self.macros.append(line.strip())

                    continue #short-cut
                else:
                    state = ST_MAIN

            if state == ST_INLINE:
                if header_re.match(line):
                    state = ST_MAIN
                    # fall through
                else:
                    items[cur_block] += line
                    continue

            if state == ST_MAIN:
                line = line.strip()
                if comment.match(line) or not line:
                    # skip comment line and empty line
                    continue

                dm = directive.match(line)
                if not dm:
                    hm = header_re.match(line)

                if dm:
                    key = dm.group(1)
                    val = dm.group(2)

                    # special case for Source and Patch
                    if key.startswith('Source'):
                        key = 'Sources'
                    elif key.startswith('Patch'):
                        key = 'Patches'

                    if key not in items:
                        items[key] = [val]
                    else:
                        items[key].append(val)

                elif hm:
                    header = hm.group(1)
                    opt = hm.group(2)
                    if header not in HEADERS:
                        raise SpecUnknowHeaderError(state, self.cur_pkg, header)

                    if header == 'package':
                        if not opt:
                            raise SpecFormatError(line)
                        self.cur_pkg = opt
                        items = self.__switch_subpkg(self.cur_pkg)

                    else:
                        # inline sections of other headers
                        state = ST_INLINE
                        if opt and not opt.startswith('-'):
                            # section with sub-pkg specified
                            self.cur_pkg = opt.split()[0]
                            items = self.__switch_subpkg(self.cur_pkg)
                        else:
                            # for 'main' package
                            items = self.items

                        cur_block = header
                        if cur_block not in items:
                            items[cur_block] = ''

                            # options in header line as the first line
                            if '-' in opt:
                                items[cur_block] = opt[opt.index('-'):] + '\n'

                else:
                    # unparsed line
                    print >> sys.stderr, 'Warning: un-parsed spec line skipped:', line

    def cooked_items(self):
        """ return all items, cooked to the input of convertor """
        return self.__cook_items('main', self.items)

    def __cook_items(self, pkg_name, items):
        """ helper function to transfer data structure
            <recursive>
        """
        #import pprint
        #pprint.pprint( items )
        #pprint.pprint( self.table )
        #pprint.pprint( self.macros )

        # pattern of macros
        macro_re = re.compile('%{(\w+)}')

        ck_items = {'extra': {}}
        if pkg_name != 'main':
            ck_items['Name'] = pkg_name

        for k, v in items.iteritems():
            if k in SKIPS or k in HEADERS or k == 'SubPackages':
                continue

            if self.table:
                # macro replacing
                nv = []
                for vi in v:
                    while macro_re.search(vi):
                        nvi = vi
                        for m in macro_re.finditer(vi):
                            macro, name = m.group(0, 1)
                            if name in self.table:
                                nvi = nvi.replace(macro, self.table[name])
                        if vi == nvi:
                            break # break to exit 'while' loop
                        vi = nvi

                    # now nvi is the replaced string
                    nv.append(vi)
                v = nv

            if k in SINGLES:
                # special case for Release
                if k == 'Release':
                    m = re.match('(\S+)%{\?dist}', v[0])
                    if m: ck_items[k] = m.group(1)
                    else: ck_items[k] = v[0]
                else:
                    ck_items[k] = v[0]

            else:
                ck_items[k] = v

        # handle all sectinos with header, IN-ORDER
        for hdr in HEADERS:
            if hdr in items:
                routine = getattr(self, '_do_' + hdr)
                routine(ck_items, pkg_name, items[hdr])

        if pkg_name != 'main':
            # shortcut for subpkg
            return ck_items

        # handle subpackages
        if 'SubPackages' in items:
            ck_items['SubPackages'] = []
            for sub, sub_items in items['SubPackages'].iteritems():
                ck_items['SubPackages'].append(self.__cook_items(sub, sub_items))

        # check must-have keys
        for key, default in MUSTHAVE.iteritems():
            if key not in ck_items:
                ck_items[key] = default

        # check for global macros
        if self.macros:
            ck_items['extra']['macros'] = self.macros

        #pprint.pprint( ck_items )
        return ck_items

def parse_options(args):
    import spectacle.__version__

    usage = "Usage: %prog [options] <spec-path>"
    parser = optparse.OptionParser(usage, version=spectacle.__version__.VERSION)

    parser.add_option("-o", "--output", type="string",
                      dest="outfile_path", default=None,
                      help="Path of output yaml file")
    parser.add_option("-r", "--replace-macros", action="store_true",
                      dest="replace_macros", default=False,
                      help="To replace self-defined macros in spec file")
    parser.add_option("",   "--no-builder-parsing", action="store_false",
                      dest="builder_parsing", default=True,
                      help="Do NOT try to parse build/install scripts")

    (options, args) = parser.parse_args()
    if not args:
        parser.error('Must specify path of spec file')
        sys.exit(1)

    return options, args

if __name__ == '__main__':
    """ Main Function """

    (options, args) = parse_options(sys.argv[1:])

    spec_fpath = args[0]

    if options.outfile_path:
        out_fpath = options.outfile_path
    else:
        out_fpath = spec_fpath.rstrip('.spec') + '.yaml'
        if spec_fpath.endswith('.spec'):
            out_fpath = spec_fpath[:-4] + 'yaml'
        else:
            out_fpath = spec_fpath + '.yaml'

    # Check if the input file exists
    if not os.path.exists(spec_fpath):
        # input file does not exist
        print "%s: File does not exist" % spec_fpath
        sys.exit(1)

    """Read the input file"""
    spec_parser = SpecParser(replace_macros = options.replace_macros,
                             builder_parsing = options.builder_parsing
                            )
    try:
        spec_parser.read(spec_fpath)
    except SpecFormatError, e:
        print 'Spec syntax error:', e
    except SpecUnknowHeaderError, e:
        print 'Unknown spec header:', e

    convertor = SpecConvertor()

    """Dump them to spectacle file"""
    dumper = SpectacleDumper(format='yaml', opath = out_fpath)
    newspec_fpath = dumper.dump(convertor.convert(spec_parser.cooked_items()))

    print 'Yaml file %s created' % out_fpath
    if newspec_fpath:
        bak_spec_fpath = spec_fpath + '.orig'
        print 'New spec file %s was created by new yaml file, and orignal spec file was saved as %s' % (newspec_fpath, bak_spec_fpath)

