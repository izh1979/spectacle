#!/usr/bin/python -tt
# vim: ai ts=4 sts=4 et sw=4

#    Copyright (c) 2009 Intel Corporation
#
#    This program is free software; you can redistribute it and/or modify it
#    under the terms of the GNU General Public License as published by the Free
#    Software Foundation; version 2 of the License
#
#    This program is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#    for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc., 59
#    Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Overview of ini2yaml
    (1) ini2yaml reads the ini file and divides it into segments.    
    (2) Parses the 'header' segment. Write out the key,value pairs 
    (3) Expand the 'Files' if found
    (4) Parse the sub-packages segments if found
"""

import os
import sys
import re
import shutil
import optparse
from ConfigParser import RawConfigParser

# spectacle modules
from spectacle.convertor import *
from spectacle.dumper import *

class SBConvertor(Convertor):
    """ Convertor for SpecBuild ini files """

    def __init__(self):
        sb_cv_table = {
                'BuildRequires': 'PkgBR',
                'PkgConfig': 'PkgConfigBR',
                'Extras': 'ExtraSources',
                'Extra': 'extra',
                }
        Convertor.__init__(self, sb_cv_table)

class SBConfigParser(RawConfigParser):
    """ SpecBuild ini specific parser """

    # keys whose value need to split to list
    multi_keys = ('Sources',
                  'Patches',
                  'Extras',
                 )

    # keys whose value may have ver numbers
    deps_keys =  ('BuildRequires',
                  'PreRequires',
                  'Requires',
                  'PostRequires',
                  'PkgConfig',
                  'Provides',
                  'Obsoletes',
                  'Conflicts',
                 )

    # keys whose value need to be expand(reading extra file)
    expand_keys =  ('Files',
                    'Description',
                    'PostMakeExtras',
                    'PostMakeInstallExtras',
                   )

    # keys need to be placed to 'extra'
    extra_keys =  ('Files',
                   'PostMakeExtras',
                   'PostMakeInstallExtras',
                   )

    # must have keys
    must_keys =  {'Release': '1',
                  'Configure': 'configure',
                 }

    def __init__(self, ini_dir = None):
        RawConfigParser.__init__(self)

        if ini_dir:
            self.ini_dir = ini_dir
        else:
            self.ini_dir = os.path.curdir

        self.record_used_files = []

    def read(self, filenames):
        """ override super read to record input files """

        if isinstance(filenames, basestring):
            filenames = [filenames]
        self.record_used_files.extend(filenames)

        return RawConfigParser.read(self, filenames)

    def optionxform(self, option):
        # Capitalize the first char
        lead = option[0]
        if lead.upper() != lead:
            return lead.upper() + option[1:]
        else:
            return option

    def __expand_single(self, filename):
        """ Helper function to expand *.desc """
        if os.path.exists(filename):
            self.record_used_files.append(filename)
            return file(filename).read().strip()
        else:
            print >> sys.stderr, "Warning: missing expected file %s" % filename
            return None

    def __cook_config(self):
        """ Helper function to update fields for spec-builder specific ones
        """
        all_items = {}
        main_extra = {} # for extra keys of main pkg

        for section in self.sections():
            items = self._sections[section]

            # Convert space seperated string to list
            for key in self.multi_keys:
                if key in items:
                    self.set(section, key, map(str.strip, items[key].split()))

            # Convert dependent like entry to list
            for key in self.deps_keys:
                if key in items:
                    reqs = []
                    for entry in re.findall('\S+\s+[<>=]+\s+\S+|\S+', items[key]):
                        reqs.append(entry.split(',')[0])
                    self.set(section, key, reqs)

            # special cases for 'ConfigOptions'
            if 'ConfigOptions' in items:
                self.set(section, 'ConfigOptions',
                            map(lambda s: '--'+s,
                                [opt for opt in map(str.strip, items['ConfigOptions'].split('--')) if opt]))

            # special cases for 'LocaleOptions'
            if 'LocaleOptions' in items and 'LocaleName' not in items:
                self.set(section, 'LocaleName', '%{name}')

            # Convert keys which need expanding from external file
            for key in self.expand_keys:
                if key in items:
                    content = self.__expand_single(
                                    os.path.join(self.ini_dir, items[key]))
                    if content:
                        if key == 'Files':
                            # 'Files' need split to list
                            self.set(section, key, content.split('\n'))
                        else:
                            self.set(section, key, content)
                    else:
                        # if file empty or file not exists, remove the empty key
                        del items[key]

            # move extra keys to 'extra' key
            extra = {}
            for key in self.extra_keys:
                if key in items:
                    extra[key] = items[key]
                    del items[key]
            if extra:
                if section not in ('header', 'configuration'):
                    self.set(section, 'extra', extra)
                else:
                    main_extra.update(extra)

        for section in self.sections():
            if section in ('header', 'configuration'):
                all_items.update(dict(self.items(section)))

        if main_extra:
            all_items['extra'] = main_extra

        # Checking must-have keys
        for key, default in self.must_keys.iteritems():
            if key not in all_items:
                all_items[key] = default

        # Re-structure sub packages to inner level
        if 'SubPackages' in all_items:
            subpkg_list = all_items['SubPackages'].split()
            all_items['SubPackages'] = []

            for subpkg in subpkg_list:
                try:
                    all_items['SubPackages'].append(dict(self.items(subpkg)))
                    all_items['SubPackages'][-1].update({'Name': subpkg})
                except NoSectionError, e:
                    print 'Needed section for sub-package %s not found' % subpkg
                    raise e

        return all_items

    def cooked_items(self):
        """ return all items, cooked to the input of convertor """
        return self.__cook_config()

def parse_options(args):
    import spectacle.__version__

    usage = "Usage: %prog [options] <ini-path>"
    parser = optparse.OptionParser(usage, version=spectacle.__version__.VERSION)

    parser.add_option("-o", "--output", type="string",
                      dest="outfile_path", default=None,
                      help="Path of output yaml file")

    (options, args) = parser.parse_args()
    if not args:
        parser.error('Must specify path of ini file')
        sys.exit(1)

    return options, args

if __name__ == '__main__':
    """ Main Function """

    (options, args) = parse_options(sys.argv[1:])

    ini_fpath = args[0]

    if options.outfile_path:
        out_fpath = options.outfile_path
    else:
        if ini_fpath.endswith('.ini'):
            out_fpath = ini_fpath[:-3] + 'yaml'
        else:
            out_fpath = ini_fpath + '.yaml'

    # Check if the input file exists
    if not os.path.exists(ini_fpath):
        # input file does not exist
        print "%s: File does not exist" % ini_fpath
        sys.exit(1)

    iniDir = os.path.dirname(ini_fpath)
    if not iniDir:
        iniDir = os.path.curdir

    """Read the input file"""
    config = SBConfigParser(iniDir)
    config.read(ini_fpath)

    convertor = SBConvertor()

    """Dump them to spectacle file"""
    dumper = SpectacleDumper(format='yaml', opath = out_fpath)
    spec_fpath = dumper.dump(convertor.convert(config.cooked_items()))

    print 'Yaml file %s created' % out_fpath
    if spec_fpath:
        print 'Spec file %s was created with extra data' % spec_fpath

    # move old spec-builder files to backup dir
    backDir = os.path.join(iniDir, 'spec-builder.backup')
    try:
        os.mkdir(backDir)
    except:
        pass
    if os.path.exists(backDir) and not os.path.isfile(backDir):
        print 'The following used spec-builder files are moved to dir:', backDir
        for file in config.record_used_files:
            print '\t', os.path.basename(file)
            shutil.move(file, backDir)
